\newglossaryentry{tamarin}
{
    name={Tamarin},
    first={Tamarin Prover},
    text={Tamarin},
    description={
            Tamarin prover è un tool in grado di verificare la correttezza formale di protocolli di sicurezza.
            È in grado di portare a termine dimostrazioni che possono evidenziare un controesempio al lemma
            che si vuole dimostrare o ne verificano la correttezza tramite l'analisi simbolica e la tecnica del \gls{multiset-rewriting}
        }
}
\newglossaryentry{cia}
{
    name={Confidentiality, Integrity, Availability (CIA)},
    first={Confidentiality, Integrity, Availability (CIA)},
    text={CIA},
    description={
            Confidentiality, Integrity e Availability sono le proprietà di sicurezza base più comuni che ci si aspetta un protocollo garantisca.
            \begin{itemize}
                \item Confidentiality: il protocollo è confidenziale, ovvero non è possibile conoscere il contenuto di un messaggio.
                \item Integrity: il messaggio non è danneggiato o alterato.
                \item Availability: il messaggio o il servizio è disponibile.
            \end{itemize}
        }
}
\newglossaryentry{multiset-rewriting}
{
    name={Multiset rewriting},
    first={multiset rewriting},
    text={multiset rewriting},
    description={
            Tecnica utilizzata da \gls{tamarin} per modellare e poi analizzare un protocollo.
            Con questo formalismo si è in grado di passare da uno stato ad un altro del sistema attraverso le regole definite.
            Si è quindi in grado di rappresentare sia il comportamento degli agenti che partecipano al protocollo, sia dell'avversario.
        }
}
\newglossaryentry{mtproto}
{
    name={MTProto},
    first={Mobile Transport Protocol (MTProto)},
    text={MTProto},
    description={
            Protocollo sviluppato da Telegram per la comunicazione sicura tra client e server.
            Viene rivolto in particolare ai dispositivi mobili.
        }
}
\newglossaryentry{rpc}
{
    name={Remote Procedure Call (RPC)},
    first={Remote Procedure Call (RPC)},
    text={RPC},
    description={
            Invocazioni effettuate da un applicativo verso un altro per fare in modo che ques'ultimo avvii
            una specifica procedura.
            Tali invocazioni possono avvenire anche tramite la rete.
            In ambito Object Oriented, si parla di Remote Method Invocation (RMI). \\
            Generalmente si verificano i seguenti passaggi:
            \begin{enumerate}
                \item L'applicativo client invoca una funzione stub, in maniera trasparente allo stesso
                \item Lo stub prepara la chiamata, con la firma della funzione ed i parametri, e la inoltra al destinatario
                \item Il sistema operativo del client esegue le procedure necessario per il trasferimento della chiamata
                \item Il sistema operativo del server riceve la chiamata e la inoltra al server stub
                \item Il server stub traduce la richiesta in una funzione eseguibile dall'applicativo di destinazione
                \item L'applicativo di destinazione esegue la funzione. La risposta seguirà il percorso inverso
            \end{enumerate}
        }
}
\newglossaryentry{ip}
{
    name={Internet Protocol address (IP address)},
    first={Internet Protocol address (IP address)},
    text={IP},
    description={
            Numero di 32 bit divisi in 4 ottetti che identifica univocamente un host all'interno di una rete.
            Più precisamente, una prima parte di lunghezza variabile (spesso i primi 24 bit) specificano la rete,
            i rimanenti i bit specificano l'indirizzo di un host che vi appartiene.
            Viene utilizzato nei protocolli di instradamento per direzionare il traffico al destinatario desiderato.
        }
}
\newglossaryentry{dhe}
{
    name={Diffie-Hellman key Exchange (DHE)},
    first={Diffie-Hellman key Exchange (DHE)},
    text={DHE},
    description={
            Protocollo utilizzato per lo scambio sicuro di chiavi crittografiche attraverso un canale insicuro.
            Esistono diversi modi di implementare questo protocollo, ma l'idea alla base è quella di condividere
            pubblicamente una funzione one-way della propria chiave segreta con l'altro peer, permettendo ad entrambi,
            ciascuno a conoscenza del proprio segreto e della funzione del segreto dell'altro, di generare una chiave crittografica condivisa.
        }
}
\newglossaryentry{kdf}
{
    name={Key Derivation Function (KDF)},
    first={Key Derivation Function (KDF)},
    text={KDF},
    description={
            Algoritmo crittografico deterministico in grado di generare una o più chiavi segrete
            prendendo in input una tupla di valori, che diventano la master key.
            Spesso ai segreti in input viene prima applicata una funzione di hash crittografica.
        }
}
\newglossaryentry{e2e}
{
    name={End To End (E2E)},
    first={End To End (E2E)},
    text={E2E},
    description={
            Protocolli che non necessitano una autorità centrale e che quindi si possono svolgere con la sola partecipazione di mittente e destinatario.
            Possono essere utilizzati per la comunicazione tra due entità, che ottengono la garanzia che nessun altro sia in grado di comprendere
            i messaggi scambiati.
        }
}
